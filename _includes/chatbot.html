<!-- Reality Lab Chatbot -->
<div id="chatbot-container" class="chatbot-container" style="display: none;">
  
  <div id="chatbot-window" class="chatbot-window">
    <div class="chatbot-header">
      <div class="chatbot-header-info">
        <div class="chatbot-title">Reality Lab Assistant</div>
        <div class="chatbot-subtitle">AIê°€ ì—°êµ¬ì‹¤ì— ëŒ€í•´ ë‹µë³€í•´ë“œë¦½ë‹ˆë‹¤!</div>
        <div class="chatbot-schedule" style="font-size: 11px; color: #888; margin-top: 2px;">ìš´ì˜ì‹œê°„: 08:00-ìµì¼ 04:00 (í•œêµ­ì‹œê°„)</div>
      </div>
      <div class="chatbot-controls">
        <div class="mode-toggle">
          <div class="toggle-labels">
            <span class="toggle-label ai-label active">AI CHAT</span>
            <span class="toggle-label search-label">ê²€ìƒ‰</span>
          </div>
          <div class="toggle-switch">
            <input type="checkbox" id="mode-toggle" class="toggle-input">
            <label for="mode-toggle" class="toggle-slider"></label>
          </div>
        </div>
        <button id="chatbot-close" class="chatbot-close">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div id="chatbot-messages" class="chatbot-messages">
      <div class="message bot-message">
        <div class="message-content">
          ì•ˆë…•í•˜ì„¸ìš”! Reality Lab Assistantì…ë‹ˆë‹¤. ğŸ¤–<br>
          ì—°êµ¬ì‹¤ì— ëŒ€í•´ ê¶ê¸ˆí•œ ê²ƒì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë¬¼ì–´ë³´ì„¸ìš”!<br>
          (í˜„ì¬ ê°œë°œì¤‘ìœ¼ë¡œ, ë‹µë³€ì´ ë¶€ì •í™•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)
        </div>
      </div>
    </div>
    
    <div class="chatbot-input-container">
      <input type="text" id="chatbot-input" class="chatbot-input" placeholder="ê¶ê¸ˆí•œ ê²ƒì„ ë¬¼ì–´ë³´ì„¸ìš”..." maxlength="200">
      <div class="think-mode-dropdown">
        <button id="think-mode-btn" class="think-mode-btn">
          <span class="think-mode-label">ë¹ ë¥¸ëª¨ë“œ</span>
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M2 4L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div id="think-mode-menu" class="think-mode-menu">
          <div class="think-mode-option" data-mode="fast">
            <span class="mode-title">ë¹ ë¥¸ëª¨ë“œ</span>
            <span class="mode-desc">ì¦‰ì‹œ ë‹µë³€</span>
          </div>
          <div class="think-mode-option" data-mode="deep">
            <span class="mode-title">ì‹¬ì¸µëª¨ë“œ</span>
            <span class="mode-desc">ê¹Šì€ ì¶”ë¡ </span>
          </div>
          <div class="think-mode-option" data-mode="test">
            <span class="mode-title">ğŸ§ª í…ŒìŠ¤íŠ¸</span>
            <span class="mode-desc">8B ê°œë°œì „ìš©</span>
          </div>
        </div>
      </div>
      <button id="chatbot-send" class="chatbot-send">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>
    
    <div class="chatbot-suggestions">
      <div class="suggestion-chips">
        <button class="suggestion-chip" data-question="ì—°êµ¬ ë¶„ì•¼ê°€ ë­”ê°€ìš”?" data-question-en="What are your research areas?">ì—°êµ¬ ë¶„ì•¼</button>
        <button class="suggestion-chip" data-question="íŒ€ êµ¬ì„±ì›ì€ ëˆ„êµ¬ì¸ê°€ìš”?" data-question-en="Who are the team members?">íŒ€ êµ¬ì„±ì›</button>
        <button class="suggestion-chip" data-question="ì—°êµ¬ì‹¤ì— ì§€ì›í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í•˜ë‚˜ìš”?" data-question-en="How can I apply to the lab?">ì§€ì› ë°©ë²•</button>
        <button class="suggestion-chip" data-question="ì—°ë½ì²˜ë¥¼ ì•Œë ¤ì£¼ì„¸ìš”" data-question-en="Please provide contact information">ì—°ë½ì²˜</button>
      </div>
      
      <div class="language-buttons">
        <button class="lang-btn active" data-lang="ko">KOR</button>
        <button class="lang-btn" data-lang="en">ENG</button>
      </div>
      
      <!-- AI Info tooltip moved inside chatbot window -->
      <div class="ai-info-wrapper ai-info-bottom-left">
        <div class="ai-info-trigger" id="ai-info-trigger">
          <div class="ai-info-icon">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 17h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        </div>
        <div class="ai-info-tooltip" id="ai-info-tooltip">
          <button class="tooltip-close" id="tooltip-close">
            <svg width="16" height="16" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="tooltip-content">
            <div class="tooltip-ko">
              <h4>ğŸ¤– Reality Lab AI Assistant</h4>
              <p><strong>ëª¨ë¸:</strong> Qwen3-4B Fine-tuned ëª¨ë¸ (Think íƒœê·¸ ì œê±°)</p>
              <p><strong>í•˜ë“œì›¨ì–´:</strong> NVIDIA RTX 4090 GPU</p>
              <p><strong>ì—°ê²°:</strong> Cloudflare Tunnel (ê³µê°œ ì ‘ì† ì§€ì›)</p>
              <p><strong>ìš´ì˜ì‹œê°„:</strong> ì˜¤ì „ 8ì‹œ ~ ìµì¼ ì˜¤ì „ 4ì‹œ (í•œêµ­ì‹œê°„ KST)</p>
              <p><strong>íœ´ì‹ì‹œê°„:</strong> ë§¤ì¼ ì˜¤ì „ 4ì‹œ ~ 8ì‹œ (ì‹œìŠ¤í…œ ìœ ì§€ë³´ìˆ˜)</p>
              <p><strong>ìë™ ì¬ì‹œì‘:</strong> ë§¤ì¼ ì˜¤ì „ 8ì‹œ, ì˜¤í›„ 6ì‹œ (í„°ë„ ê°±ì‹ )</p>
              <p><strong>ì—…ë°ì´íŠ¸:</strong> ë§¤ì£¼ ì¼ìš”ì¼ ì˜¤ì „ 2ì‹œ ìë™ ì—…ë°ì´íŠ¸</p>
              <br>
              <p><strong>ë™ì‘ ë°©ì‹:</strong></p>
              <p>â€¢ <em>ê²€ìƒ‰ ëª¨ë“œ:</em> ì‚¬ì „ êµ¬ì¶•ëœ Knowledge Baseì—ì„œ ì •ë³´ ê²€ìƒ‰</p>
              <p>â€¢ <em>AI ì„œë²„ ëª¨ë“œ:</em> Fine-tuned Qwen3-4Bê°€ ìì—°ì–´ë¡œ ì‹¤ì‹œê°„ ë‹µë³€ ìƒì„±</p>
            </div>
            <div class="tooltip-en" style="display: none;">
              <h4>ğŸ¤– Reality Lab AI Assistant</h4>
              <p><strong>Model:</strong> Fine-tuned Qwen3-4B (Think tags removed)</p>
              <p><strong>Hardware:</strong> NVIDIA RTX 4090 GPU</p>
              <p><strong>Connection:</strong> Cloudflare Tunnel (Public access enabled)</p>
              <p><strong>Operating Hours:</strong> 8 AM ~ 4 AM next day (KST - Korea Standard Time)</p>
              <p><strong>Rest Time:</strong> Daily 4 AM ~ 8 AM (System maintenance)</p>
              <p><strong>Auto-restart:</strong> Daily at 8 AM & 6 PM (Tunnel refresh)</p>
              <p><strong>Updates:</strong> Auto-update every Sunday 2 AM KST</p>
              <br>
              <p><strong>How it works:</strong></p>
              <p>â€¢ <em>Search Mode:</em> Searches pre-built Knowledge Base</p>
              <p>â€¢ <em>AI Server Mode:</em> Fine-tuned Qwen3-4B generates real-time natural language responses</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Question Submission Modal -->
<div id="question-modal" class="question-modal" style="display: none;">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <div class="modal-header">
      <h3>ì§ˆë¬¸ ì¶”ê°€ ìš”ì²­</h3>
      <button class="modal-close" id="modal-close">&times;</button>
    </div>
    <div class="modal-body">
      <p>ê¶ê¸ˆí•œ ë‚´ìš©ì„ ë‚¨ê²¨ì£¼ì‹œë©´, ì—°êµ¬ì‹¤ ê´€ê³„ìê°€ ê²€í†  í›„ ë‹µë³€ì„ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.</p>
      <textarea id="question-textarea" placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”..." maxlength="500"></textarea>
      <div class="char-count">
        <span id="char-count">0</span> / 500
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" id="modal-cancel">ì·¨ì†Œ</button>
      <button class="btn-primary" id="modal-send">ë³´ë‚´ê¸°</button>
    </div>
  </div>
</div>

<style>
/* Chatbot Styles */
.chatbot-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.chatbot-window {
  position: absolute;
  bottom: 80px;
  right: 0;
  width: 450px;
  height: 600px;
  min-width: 320px;
  min-height: 400px;
  max-width: 800px;
  max-height: 800px;
  background: #ffffff !important;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 16px;
  display: none;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
  resize: both;
  overflow: hidden;
}

.chatbot-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  cursor: move;
  user-select: none;
  background: linear-gradient(135deg, rgba(51, 102, 204, 0.1) 0%, rgba(41, 84, 179, 0.15) 100%);
  border-radius: 16px 16px 0 0;
}

.chatbot-title {
  font-size: 16px;
  font-weight: 600;
  color: #1a1a1a;
}

.chatbot-subtitle {
  font-size: 12px;
  color: #6b7280;
  margin-top: 2px;
}

.chatbot-close {
  background: transparent !important;
  border: none;
  cursor: pointer;
  color: #6b7280;
  padding: 4px;
  border-radius: 6px;
}

.chatbot-close:hover {
  background: rgba(0, 0, 0, 0.05) !important;
}

.chatbot-controls {
  display: flex;
  align-items: center;
  gap: 16px;
}

.mode-toggle {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.toggle-labels {
  display: flex;
  gap: 8px;
  font-size: 11px;
  font-weight: 500;
}

.toggle-label {
  color: #6b7280;
  transition: color 0.2s ease;
}

.toggle-label.active {
  color: #3366cc;
  font-weight: 600;
}

.toggle-switch {
  position: relative;
  width: 44px;
  height: 24px;
}

.toggle-input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #3366cc;
  border-radius: 24px;
  transition: all 0.3s ease;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 0px;
  top: -2px;
  background: white;
  border-radius: 50%;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toggle-input:checked + .toggle-slider {
  background: #10b981;
}

.toggle-input:checked + .toggle-slider:before {
  transform: translateX(25px);
}

/* Fix toggle direction - when checked should be search mode (right position) */
.toggle-input:checked ~ .toggle-labels .search-label {
  color: #10b981;
  font-weight: 600;
}

.toggle-input:checked ~ .toggle-labels .ai-label {
  color: #6b7280;
  font-weight: 500;
}

.toggle-input:not(:checked) ~ .toggle-labels .ai-label {
  color: #3366cc;
  font-weight: 600;
}

.toggle-input:not(:checked) ~ .toggle-labels .search-label {
  color: #6b7280;
  font-weight: 500;
}



.chatbot-messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.message {
  display: flex;
  flex-direction: column;
}

.bot-message .message-content {
  background: #f3f4f6;
  color: #1a1a1a;
  border-radius: 18px 18px 18px 4px;
  padding: 12px 16px;
  max-width: 85%;
  font-size: 14px;
  line-height: 1.4;
  border: 2px solid #d1d5db;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.user-message {
  align-items: flex-end;
}

.user-message .message-content {
  background: #3366cc;
  color: white;
  border-radius: 18px 18px 4px 18px;
  padding: 12px 16px;
  max-width: 85%;
  font-size: 14px;
  line-height: 1.4;
  border: 2px solid #2952a3;
  box-shadow: 0 2px 8px rgba(51, 102, 204, 0.25);
}

.chatbot-input-container {
  display: flex;
  padding: 16px 20px 10px;
  gap: 12px;
}

.chatbot-input {
  flex: 1;
  border: 2px solid #e5e7eb;
  border-radius: 24px;
  padding: 12px 16px;
  font-size: 14px;
  outline: none;
  transition: border-color 0.2s ease;
}

.chatbot-input:focus {
  border-color: #3366cc;
}

/* Think Mode Dropdown */
.think-mode-dropdown {
  position: relative;
  margin-right: 8px;
}

.think-mode-btn {
  background: rgba(59, 130, 246, 0.4);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(59, 130, 246, 0.5);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 13px;
  color: #1e40af;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 600;
}

.think-mode-btn:hover {
  background: rgba(59, 130, 246, 0.55);
  border-color: rgba(59, 130, 246, 0.7);
}

.think-mode-btn svg {
  transition: transform 0.2s ease;
}

.think-mode-btn.active svg {
  transform: rotate(180deg);
}

.think-mode-menu {
  position: absolute;
  bottom: calc(100% + 8px);
  left: 0;
  background: rgba(59, 130, 246, 0.35);
  backdrop-filter: blur(15px);
  border: 1px solid rgba(59, 130, 246, 0.5);
  border-radius: 10px;
  padding: 4px;
  min-width: 160px;
  box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
  display: none;
  z-index: 1000;
}

.think-mode-menu.show {
  display: block;
  animation: slideDown 0.2s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.think-mode-option {
  padding: 10px 12px;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.think-mode-option:hover {
  background: rgba(59, 130, 246, 0.5);
}

.think-mode-option.selected {
  background: rgba(59, 130, 246, 0.6);
}

.think-mode-option .mode-title {
  font-size: 14px;
  font-weight: 600;
  color: #1e40af;
}

.think-mode-option .mode-desc {
  font-size: 11px;
  color: #3b82f6;
  opacity: 0.8;
}

.chatbot-send {
  background: #3366cc;
  color: white;
  border: none;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.chatbot-send:hover {
  background: #2954b3;
}

.chatbot-suggestions {
  padding: 10px 20px 20px;
}

.suggestion-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.suggestion-chip {
  background: rgba(51, 102, 204, 0.1);
  color: #3366cc;
  border: 1px solid rgba(51, 102, 204, 0.2);
  border-radius: 16px;
  padding: 6px 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.suggestion-chip:hover {
  background: rgba(51, 102, 204, 0.2);
}

.language-buttons {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
  margin-top: 12px;
}

.lang-btn {
  background: rgba(255, 255, 255, 0.8);
  border: 1px solid #3366cc;
  border-radius: 10px;
  padding: 4px 8px;
  font-size: 10px;
  font-weight: 600;
  color: #3366cc;
  cursor: pointer;
  transition: all 0.3s ease;
  user-select: none;
}

.lang-btn:hover {
  background: rgba(51, 102, 204, 0.1);
  border: 1px solid #3366cc;
  transform: translateY(-1px);
}

.lang-btn.active {
  background: rgba(51, 102, 204, 0.2);
  border: 1px solid #3366cc;
  color: #3366cc;
  box-shadow: 0 2px 8px rgba(51, 102, 204, 0.2);
}

/* AI Info tooltip styles */
.ai-info-wrapper {
  position: relative;
  display: inline-block;
  margin-right: 12px;
}

.ai-info-trigger {
  display: flex !important;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease;
  padding: 6px;
  border-radius: 50%;
  background: rgba(128, 128, 128, 0.1);
  border: 1px solid rgba(128, 128, 128, 0.2);
  visibility: visible !important;
  opacity: 1 !important;
}

.ai-info-trigger:hover {
  background: rgba(128, 128, 128, 0.2);
  border: 1px solid rgba(128, 128, 128, 0.3);
}

.ai-info-icon {
  width: 18px;
  height: 18px;
  display: flex !important;
  align-items: center;
  justify-content: center;
  color: #888 !important;
  visibility: visible !important;
  opacity: 1 !important;
}

.ai-info-trigger:hover .ai-info-icon {
  color: #555 !important;
}

.ai-info-tooltip {
  position: absolute;
  bottom: 100%;
  left: 0;
  margin-bottom: 8px;
  background: #ffffff !important;
  color: #1a1a1a !important;
  padding: 16px 20px;
  border-radius: 12px;
  min-width: 350px;
  max-width: 400px;
  font-size: 13px;
  line-height: 1.5;
  opacity: 0;
  visibility: hidden;
  transform: translateY(10px);
  transition: all 0.3s ease;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
  pointer-events: none;
  border: 2px solid #e5e7eb;
}

.ai-info-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 20px;
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 8px solid #ffffff;
}

.ai-info-tooltip.show {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
  pointer-events: auto;
}

.tooltip-close {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 24px;
  height: 24px;
  border: none;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #6b7280 !important;
  transition: all 0.2s ease;
  z-index: 1001;
}

.tooltip-close:hover {
  background: rgba(0, 0, 0, 0.1);
  transform: scale(1.1);
}

.ai-info-tooltip h4 {
  margin: 0 0 12px 0;
  font-size: 15px;
  font-weight: 600;
  color: #3366cc !important;
}

.ai-info-tooltip p {
  margin: 8px 0;
  font-size: 12px;
  color: #1a1a1a !important;
}

.ai-info-tooltip strong {
  color: #1a1a1a !important;
  font-weight: 600;
}

.ai-info-tooltip em {
  color: #16a34a !important;
  font-style: normal;
  font-weight: 500;
}

.ai-info-tooltip a {
  color: #3366cc !important;
  text-decoration: none;
  font-weight: 500;
}

.ai-info-tooltip a:hover {
  text-decoration: underline;
}

/* Mobile responsive */
@media (max-width: 768px) {
  .chatbot-container {
    bottom: 15px;
    right: 15px;
    left: 15px;
  }
  
  .chatbot-window {
    width: 100%;
    height: 70vh;
    bottom: 70px;
    left: 0;
    right: 0;
    position: fixed;
  }
  
  .chatbot-toggle {
    width: fit-content;
    margin-left: auto;
  }
  
  .chatbot-text {
    display: none;
  }
}

/* Bottom-left positioned help icon */
.ai-info-bottom-left {
  position: absolute !important;
  bottom: 15px !important;
  left: 15px !important;
  margin-right: 0 !important;
  z-index: 1005 !important;
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
}

.ai-info-bottom-left .ai-info-tooltip {
  bottom: 100% !important;
  left: 0 !important;
  margin-bottom: 8px !important;
}

.ai-info-bottom-left .ai-info-tooltip::after {
  left: 20px !important;
}

/* Question Modal Styles */
.question-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
}

.modal-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: -1;
  pointer-events: auto;
}

.modal-content {
  position: relative;
  background: #ffffff !important;
  border-radius: 16px;
  width: 90%;
  max-width: 500px;
  max-height: 80vh;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
  overflow: hidden;
  z-index: 10;
  pointer-events: auto;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid #e5e7eb;
  background: linear-gradient(135deg, rgba(51, 102, 204, 0.1) 0%, rgba(41, 84, 179, 0.15) 100%);
}

.modal-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #1a1a1a;
}

.modal-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #6b7280;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: all 0.2s ease;
}

.modal-close:hover {
  background: rgba(0, 0, 0, 0.1);
  color: #1a1a1a;
}

.modal-body {
  padding: 24px;
}

.modal-body p {
  margin: 0 0 16px 0;
  color: #4b5563;
  font-size: 14px;
  line-height: 1.5;
}

#question-textarea {
  width: 100%;
  min-height: 120px;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  outline: none;
  transition: border-color 0.2s ease;
}

#question-textarea:focus {
  border-color: #3366cc;
}

.char-count {
  text-align: right;
  margin-top: 8px;
  font-size: 12px;
  color: #6b7280;
}

.modal-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 20px 24px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

.btn-secondary, .btn-primary {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-secondary {
  background: #f3f4f6;
  color: #374151;
}

.btn-secondary:hover {
  background: #e5e7eb;
}

.btn-primary {
  background: #3366cc;
  color: white;
}

.btn-primary:hover {
  background: #2954b3;
}

.btn-primary:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}

/* Envelope emoji styling */
.envelope-emoji {
  cursor: pointer;
  font-size: 16px;
  margin: 0 4px;
  transition: transform 0.2s ease;
}

.envelope-emoji:hover {
  transform: scale(1.1);
}

/* Typing cursor - Blue circle with pulse animation */
.typing-cursor {
  display: inline-block;
  width: 8px;
  height: 8px;
  background-color: #3B82F6;
  border-radius: 50%;
  margin-left: 4px;
  animation: pulse 1.5s ease-in-out infinite;
  vertical-align: middle;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.3;
    transform: scale(0.8);
  }
}
</style>

<script>
// Chatbot Knowledge Base (injected from Jekyll data)
const knowledgeBase = {{ site.data.chatbot_knowledge | jsonify }};

// Chatbot functionality
document.addEventListener('DOMContentLoaded', function() {
  const chatbotToggle = document.getElementById('chatbot-toggle');
  const chatbotWindow = document.getElementById('chatbot-window');
  const chatbotClose = document.getElementById('chatbot-close');
  const aiSearchBtn = document.getElementById('ai-search');
  const chatbotInput = document.getElementById('chatbot-input');
  const chatbotSend = document.getElementById('chatbot-send');
  const chatbotMessages = document.getElementById('chatbot-messages');
  const suggestionChips = document.querySelectorAll('.suggestion-chip');
  const thinkModeBtn = document.getElementById('think-mode-btn');
  const thinkModeMenu = document.getElementById('think-mode-menu');
  const thinkModeOptions = document.querySelectorAll('.think-mode-option');

  // Mode toggle elements
  const modeToggle = document.getElementById('mode-toggle');
  const searchLabel = document.querySelector('.search-label');
  const aiLabel = document.querySelector('.ai-label');
  const chatbotSubtitle = document.querySelector('.chatbot-subtitle');
  const chatbotTitle = document.querySelector('.chatbot-title');


  // Language button elements
  const langButtons = document.querySelectorAll('.lang-btn');
  const suggestionChipsElements = document.querySelectorAll('.suggestion-chip');
  const chatbotSchedule = document.querySelector('.chatbot-schedule');

  // Current modes - Start in AI mode as requested
  let isAIMode = true;
  let isEnglish = false;
  let selectedModel = 'qwen3-4b';

  // Chat mode - Initialize from localStorage (default: 'fast')
  // Modes: 'fast' (ë¹ ë¥¸ëª¨ë“œ), 'deep' (ì‹¬ì¸µëª¨ë“œ), 'test' (í…ŒìŠ¤íŠ¸ëª¨ë“œ - 8B)
  let chatMode = localStorage.getItem('chatMode') || 'fast';
  const thinkModeLabel = document.querySelector('.think-mode-label');

  // Set initial UI state
  function updateThinkModeUI() {
    const modeLabels = {
      'fast': 'ë¹ ë¥¸ëª¨ë“œ',
      'deep': 'ì‹¬ì¸µëª¨ë“œ',
      'test': 'ğŸ§ª í…ŒìŠ¤íŠ¸'
    };
    thinkModeLabel.textContent = modeLabels[chatMode] || 'ë¹ ë¥¸ëª¨ë“œ';
    thinkModeOptions.forEach(opt => {
      opt.classList.toggle('selected', opt.dataset.mode === chatMode);
    });
  }

  updateThinkModeUI();

  // GPU allocation system
  let currentSession = null;
  let currentEndpoint = null;
  let isConnecting = false;

  // Rate limiting - 20 requests, then 2 minute cooldown
  const MAX_REQUESTS = 20;
  const COOLDOWN_TIME = 2 * 60 * 1000; // 2 minutes cooldown after hitting limit

  // Load rate limit data from localStorage (persists across page reloads)
  let requestCount = parseInt(localStorage.getItem('aiChatRequestCount') || '0');
  let cooldownEndTime = parseInt(localStorage.getItem('aiChatCooldownEnd') || '0');
  
  // GPU Manager endpoint (set to actual cloudflare URL when available)
  const GPU_MANAGER_URL = null; // Example: 'https://your-tunnel.trycloudflare.com'

  // Direct AI server endpoint (fallback when GPU_MANAGER_URL is null)
  const DIRECT_AI_SERVER_URL = 'https://underwear-coffee-maine-steady.trycloudflare.com';
  
  // Page visitor management
  let visitorSessionTimer = null;
  let lastActivityTime = Date.now();
  const VISITOR_SESSION_TIMEOUT = 5 * 60 * 1000; // 5 minutes
  
  // AI server connection status
  let isAIServerReady = false;
  let heartbeatInterval = null;
  const HEARTBEAT_INTERVAL_MS = 30000; // 30 seconds

  // Preconnect to AI server on page load
  async function preconnectAIServer() {
    try {
      console.log('ğŸ”„ Preconnecting to AI server...');
      const response = await fetch(`${DIRECT_AI_SERVER_URL}/health`, {
        method: 'GET',
        signal: AbortSignal.timeout(5000) // 5 second timeout
      });

      if (response.ok) {
        const data = await response.json();
        if (data.status === 'healthy') {
          isAIServerReady = true;
          if (data.model_loaded) {
            console.log('âœ… AI server ready:', data.model_name);
          } else {
            console.log('âœ… AI server healthy (model will auto-load on first request)');
          }
        } else {
          console.warn('âš ï¸ AI server responded but not healthy');
        }
      }
    } catch (error) {
      console.warn('âš ï¸ AI server preconnection failed:', error.message);
      // Server will still work, just might be slower on first request
    }
  }

  // Send heartbeat to keep server alive
  async function sendHeartbeat() {
    try {
      const response = await fetch(`${DIRECT_AI_SERVER_URL}/heartbeat`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        signal: AbortSignal.timeout(5000)
      });

      if (response.ok) {
        const data = await response.json();
        console.log('ğŸ’“ Heartbeat sent:', data.message);
      }
    } catch (error) {
      console.warn('âš ï¸ Heartbeat failed:', error.message);
    }
  }

  // Start heartbeat system
  function startHeartbeat() {
    if (heartbeatInterval) return; // Already running

    // Send initial heartbeat immediately
    sendHeartbeat();

    // Send heartbeat every 30 seconds
    heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL_MS);
    console.log('ğŸ’“ Heartbeat system started');
  }

  // Stop heartbeat system
  function stopHeartbeat() {
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
      console.log('ğŸ’“ Heartbeat system stopped');
    }
  }

  // Stop heartbeat when user leaves page
  window.addEventListener('beforeunload', () => {
    stopHeartbeat();
  });

  // Stop heartbeat when page is hidden (tab switch, minimize)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      stopHeartbeat();
    } else {
      startHeartbeat();
    }
  });

  // Automatically allocate GPU when page loads
  if (GPU_MANAGER_URL) {
    initializeVisitorSession();
  } else {
    // Direct connection mode - set default endpoint and preconnect
    currentEndpoint = DIRECT_AI_SERVER_URL;
    console.log('ğŸ”— Direct AI server connection mode: ' + DIRECT_AI_SERVER_URL);
    preconnectAIServer(); // Preconnect immediately
    startHeartbeat(); // Start keeping server alive
  }
  
  // Get current session endpoints
  function getCurrentEndpoints() {
    if (currentEndpoint) {
      return {
        health: `${currentEndpoint}/health`,
        chat: `${currentEndpoint}/chat`,
        submitQuestion: `${currentEndpoint}/submit-question`
      };
    }
    return null;
  }

  // Initialize visitor session - allocate GPU when user visits page
  async function initializeVisitorSession() {
    if (!GPU_MANAGER_URL) {
      console.log('ğŸš« GPU Manager disabled - skipping allocation');
      return;
    }
    
    console.log('ğŸ  Visitor detected - initializing GPU session...');
    
    // Allocate GPU immediately when user visits page
    const session = await allocateGPU();
    if (session) {
      console.log('âœ… GPU allocated for visitor session');
      startVisitorSessionTimer();
      setupActivityListeners();
    } else {
      console.log('âŒ Failed to allocate GPU for visitor - retrying in 10 seconds');
      setTimeout(initializeVisitorSession, 10000);
    }
  }
  
  // Setup activity listeners to detect user interaction
  function setupActivityListeners() {
    const activities = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
    
    activities.forEach(activity => {
      document.addEventListener(activity, updateLastActivity, { passive: true });
    });
    
    // Also listen for visibility changes
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }
  
  // Update last activity time
  function updateLastActivity() {
    lastActivityTime = Date.now();
    // Reset visitor session timer
    startVisitorSessionTimer();
  }
  
  // Handle page visibility changes
  function handleVisibilityChange() {
    if (document.visibilityState === 'visible') {
      // User came back to page
      updateLastActivity();
      console.log('ğŸ‘ï¸ User returned to page');
    } else {
      // User switched away from page - start 5-minute countdown
      console.log('ğŸ˜´ User left page - 5 minute countdown started');
      startVisitorSessionTimer();
    }
  }
  
  // Start or restart visitor session timer (5 minutes)
  function startVisitorSessionTimer() {
    if (visitorSessionTimer) {
      clearTimeout(visitorSessionTimer);
    }
    
    visitorSessionTimer = setTimeout(() => {
      const timeSinceLastActivity = Date.now() - lastActivityTime;
      
      if (timeSinceLastActivity >= VISITOR_SESSION_TIMEOUT) {
        console.log('â° 5 minutes of inactivity - releasing GPU session');
        releaseGPUSession();
      } else {
        // Still active, restart timer
        const remainingTime = VISITOR_SESSION_TIMEOUT - timeSinceLastActivity;
        console.log(`ğŸ”„ User still active - restarting timer for ${Math.round(remainingTime/1000)} seconds`);
        setTimeout(startVisitorSessionTimer, remainingTime);
      }
    }, VISITOR_SESSION_TIMEOUT);
  }
  
  // Release GPU session
  async function releaseGPUSession() {
    if (!currentSession) {
      return;
    }
    
    try {
      console.log('ğŸ”„ Releasing GPU session...');
      const response = await fetch(`${GPU_MANAGER_URL}/release`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ session_id: currentSession.session_id })
      });
      
      if (response.ok) {
        console.log('âœ… GPU session released successfully');
      } else {
        console.log('âš ï¸ Failed to release GPU session');
      }
    } catch (error) {
      console.error('âŒ Error releasing GPU session:', error);
    } finally {
      currentSession = null;
      currentEndpoint = null;
      if (visitorSessionTimer) {
        clearTimeout(visitorSessionTimer);
        visitorSessionTimer = null;
      }
    }
  }

  // Allocate GPU for AI session
  async function allocateGPU() {
    if (isConnecting || currentSession) {
      return currentSession;
    }
    
    isConnecting = true;
    
    try {
      const response = await fetch(`${GPU_MANAGER_URL}/allocate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
      });
      
      const data = await response.json();
      
      if (data.success) {
        currentSession = data;
        currentEndpoint = data.endpoint;
        console.log(`âœ… GPU ${data.gpu_id} í• ë‹¹ë¨: ${data.endpoint}`);
        return currentSession;
      } else {
        console.error('âŒ GPU í• ë‹¹ ì‹¤íŒ¨:', data.error);
        return null;
      }
    } catch (error) {
      console.error('âŒ GPU ë§¤ë‹ˆì € ì—°ê²° ì‹¤íŒ¨:', error);
      return null;
    } finally {
      isConnecting = false;
    }
  }
  
  // Release current GPU session
  async function releaseGPU() {
    if (!currentSession) return;
    
    try {
      await fetch(`${GPU_MANAGER_URL}/release`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          session_id: currentSession.session_id
        })
      });
      
      console.log(`ğŸ”„ GPU ${currentSession.gpu_id} í•´ì œë¨`);
    } catch (error) {
      console.error('GPU í•´ì œ ì‹¤íŒ¨:', error);
    } finally {
      currentSession = null;
      currentEndpoint = null;
    }
  }

  // Global variable for request cancellation
  let currentAIRequest = null;

  // Generate AI response using dynamic GPU allocation
  async function generateAIResponse(question) {
    try {
      // Check rate limiting with localStorage persistence
      const currentTime = Date.now();

      // Check if we're in cooldown period
      if (cooldownEndTime > 0 && currentTime < cooldownEndTime) {
        const timeLeft = Math.ceil((cooldownEndTime - currentTime) / 60000); // minutes
        const secondsLeft = Math.ceil((cooldownEndTime - currentTime) / 1000) % 60;
        return {
          response: isEnglish ?
            `â±ï¸ You've reached the limit of ${MAX_REQUESTS} requests. Please try again in ${timeLeft}:${secondsLeft.toString().padStart(2, '0')}.` :
            `â±ï¸ ${MAX_REQUESTS}íšŒ ìš”ì²­ ì œí•œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ${timeLeft}ë¶„ ${secondsLeft}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`,
          response_time: null
        };
      }

      // If cooldown has ended, reset everything
      if (cooldownEndTime > 0 && currentTime >= cooldownEndTime) {
        requestCount = 0;
        cooldownEndTime = 0;
        localStorage.setItem('aiChatRequestCount', '0');
        localStorage.setItem('aiChatCooldownEnd', '0');
      }

      // Check if we've hit the limit
      if (requestCount >= MAX_REQUESTS) {
        // Start cooldown
        cooldownEndTime = currentTime + COOLDOWN_TIME;
        localStorage.setItem('aiChatCooldownEnd', cooldownEndTime.toString());

        const timeLeft = Math.ceil(COOLDOWN_TIME / 60000);
        return {
          response: isEnglish ?
            `â±ï¸ You've reached the limit of ${MAX_REQUESTS} requests. Please try again in ${timeLeft} minutes.` :
            `â±ï¸ ${MAX_REQUESTS}íšŒ ìš”ì²­ ì œí•œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ${timeLeft}ë¶„ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`,
          response_time: null
        };
      }

      // Increment request counter and save to localStorage
      requestCount++;
      localStorage.setItem('aiChatRequestCount', requestCount.toString());

      // Cancel previous request if exists
      if (currentAIRequest) {
        currentAIRequest.abort();
        console.log('Previous AI request cancelled');
      }
      
      // Check if GPU session is available (only for GPU Manager mode)
      if (GPU_MANAGER_URL && !currentSession) {
        // Try to allocate if somehow not available
        console.log('âš ï¸ No GPU session found, attempting to allocate...');
        const session = await allocateGPU();
        if (!session) {
          return {
            response: isEnglish ?
              "ğŸ’¤ AI is currently taking a break. Please try during operating hours (08:00-04:00 KST)!" :
              "ğŸ’¤ AIê°€ ì§€ê¸ˆ ì‰¬ëŠ” ì‹œê°„ì´ì—ìš”. ìš´ì˜ì‹œê°„(08:00-ìµì¼ 04:00)ì— ë‹¤ì‹œ ì°¾ì•„ì£¼ì„¸ìš”!",
            response_time: null
          };
        }
      }
      
      const endpoints = getCurrentEndpoints();
      if (!endpoints) {
        return {
          response: isEnglish ?
            "ğŸ’¤ AI is currently resting. Please visit during operating hours (08:00-04:00 KST)!" :
            "ğŸ’¤ AIê°€ ì§€ê¸ˆ íœ´ì‹ì¤‘ì´ì—ìš”. ìš´ì˜ì‹œê°„(08:00-ìµì¼ 04:00)ì— ë‹¤ì‹œ ì°¾ì•„ì£¼ì„¸ìš”!",
          response_time: null
        };
      }
      
      // Update user activity since they're using AI chat
      updateLastActivity();
      
      // Call chat endpoint with auto-save functionality (no timeout)
      const controller = new AbortController();
      currentAIRequest = controller; // Store for cancellation

      // Determine request parameters based on chat mode
      const currentChatMode = localStorage.getItem('chatMode') || 'fast';
      const requestBody = {
        question: question,
        language: isEnglish ? 'en' : 'ko',
        max_length: 700,
        think_mode: currentChatMode === 'deep',
        model_choice: currentChatMode === 'test' ? 'qwen3-8b' : 'qwen3-4b'
      };

      const response = await fetch(endpoints.chat, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': currentSession ? currentSession.session_id : '',
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });

      currentAIRequest = null; // Clear after completion

      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();
      console.log('AI Response:', data);
      
      // Show success message if auto-saved
      if (data.auto_saved) {
        console.log('âœ… AI ëŒ€í™”ê°€ GitHubì— ìë™ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
      }

      return {
        response: data.response || (isEnglish ? "Sorry, no response generated." : "ì‘ë‹µì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
        response_time: data.response_time,
        tokens: data.tokens || null
      };

    } catch (error) {
      console.error('Error calling AI server:', error);
      currentAIRequest = null;

      return {
        response: isEnglish ?
          "ğŸ’¤ AI is currently taking a break (04:00-08:00 KST). Please come back during operating hours!" :
          "ğŸ’¤ AIê°€ ì§€ê¸ˆ ì‰¬ëŠ” ì‹œê°„ì´ì—ìš” (04:00-08:00 í•œêµ­ì‹œê°„). ìš´ì˜ì‹œê°„ì— ë‹¤ì‹œ ì°¾ì•„ì£¼ì„¸ìš”!",
        response_time: null,
        tokens: null
      };
    }
  }

  // Call AI Server with Streaming (EventSource)
  async function callAIServerStream(question, isEnglish = false) {
    if (!currentEndpoint) {
      return {
        response: isEnglish ? "Server not configured" : "ì„œë²„ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤",
        response_time: null,
        tokens: null
      };
    }

    return new Promise((resolve, reject) => {
      const url = `${currentEndpoint}/chat/stream`;
      let fullResponse = "";
      let responseTime = null;
      let tokens = null;

      // Create EventSource manually using fetch for POST
      fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          question: question,
          language: isEnglish ? 'en' : 'ko',
          max_length: 700
        }),
      }).then(response => {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        function readChunk() {
          return reader.read().then(({ value, done }) => {
            if (done) {
              resolve({
                response: fullResponse,
                response_time: responseTime,
                tokens: tokens
              });
              return;
            }

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonData = line.substring(6);
                try {
                  const data = JSON.parse(jsonData);

                  if (data.error) {
                    reject(new Error(data.error));
                    return;
                  }

                  // Handle loading status
                  if (data.status === 'loading') {
                    fullResponse = data.text;
                    updateStreamingMessage(fullResponse);
                    // Continue reading to get [DONE] signal
                  }

                  if (data.text && !data.done && data.status !== 'loading') {
                    fullResponse += data.text;
                    // Update the bot message in real-time
                    updateStreamingMessage(fullResponse);
                  }

                  if (data.done) {
                    responseTime = data.response_time;
                    tokens = data.tokens;
                  }
                } catch (e) {
                  // Skip invalid JSON
                }
              }
            }

            return readChunk();
          });
        }

        return readChunk();
      }).catch(error => {
        reject(error);
      });
    });
  }

  // Update streaming message in real-time
  function updateStreamingMessage(text) {
    const messages = chatbotMessages.querySelectorAll('.message');
    const lastMessage = messages[messages.length - 1];

    if (lastMessage && lastMessage.classList.contains('bot-message')) {
      const contentDiv = lastMessage.querySelector('div:first-child');
      if (contentDiv) {
        contentDiv.innerHTML = text.replace(/\n/g, '<br>') + '<span class="typing-cursor"></span>';
      }
    }
  }

  // Toggle chatbot (global function)
  window.toggleChatbot = function() {
    const container = document.getElementById('chatbot-container');
    const chatbotWindow = document.getElementById('chatbot-window');
    if (chatbotWindow.style.display === 'flex') {
      chatbotWindow.style.display = 'none';
    } else {
      container.style.display = 'block';
      chatbotWindow.style.display = 'flex';
    }
  }
  
  // AI Search button in navigation
  if (aiSearchBtn) {
    aiSearchBtn.addEventListener('click', (e) => {
      e.preventDefault();
      window.toggleChatbot();
    });
  }
  
  // Also look for AI button by id
  const aiButtonById = document.getElementById('ai-search');
  if (aiButtonById) {
    aiButtonById.addEventListener('click', (e) => {
      e.preventDefault();
      window.toggleChatbot();
    });
  }
  
  // Look for AI Chat triggers by class name
  const aiChatTriggers = document.querySelectorAll('.ai-chat-trigger');
  aiChatTriggers.forEach(trigger => {
    trigger.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('AI Chat trigger clicked');
      window.toggleChatbot();
    });
  });
  
  // Also look for any element with AI-related classes (fallback)
  const aiButtons = document.querySelectorAll('[href="#ai"], [href="#"], .ai-search-btn, a[title="AI"]');
  aiButtons.forEach(btn => {
    if (btn.textContent.includes('AI') || btn.id === 'ai-search' || btn.href?.includes('#ai')) {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        console.log('AI fallback trigger clicked');
        window.toggleChatbot();
      });
    }
  });

  chatbotClose.addEventListener('click', () => {
    const container = document.getElementById('chatbot-container');
    chatbotWindow.style.display = 'none';
    container.style.display = 'none';
  });

  // Mode toggle functionality - Switch between AI Server and Search
  if (modeToggle) {
    modeToggle.addEventListener('change', function() {
      // Reverse logic: checked = search mode, unchecked = AI mode
      isAIMode = !this.checked;
      updateModeUI();
      
      // Check AI server when switching to AI mode
      if (isAIMode) {
        checkAIServer();
      }
    });
  }
  

  // Initialize in AI mode by default and set toggle accordingly
  if (modeToggle) {
    modeToggle.checked = false; // unchecked = AI mode
  }
  updateAllUI();
  
  // Clean up GPU session when page is closed or user leaves
  window.addEventListener('beforeunload', () => {
    if (currentSession) {
      // Use sendBeacon for reliable cleanup
      navigator.sendBeacon(`${GPU_MANAGER_URL}/release`, JSON.stringify({
        session_id: currentSession.session_id
      }));
    }
  });
  
  // Also release GPU when visibility changes (tab switch, etc)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden' && currentSession) {
      releaseGPU();
    }
  });

  function updateModeUI() {
    updateAllUI();
  }

  // Language button functionality
  langButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      const lang = this.getAttribute('data-lang');
      isEnglish = (lang === 'en');
      updateLanguageUI();
    });
  });

  function updateLanguageUI() {
    updateAllUI();
  }

  function updateAllUI() {
    // Update language button states
    langButtons.forEach(btn => {
      const lang = btn.getAttribute('data-lang');
      if ((lang === 'en' && isEnglish) || (lang === 'ko' && !isEnglish)) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    // Update suggestion chips
    suggestionChipsElements.forEach(chip => {
      if (isEnglish) {
        const englishText = chip.getAttribute('data-question-en');
        const englishLabels = ['Research Areas', 'Team Members', 'Application', 'Contact'];
        const index = Array.from(suggestionChipsElements).indexOf(chip);
        chip.textContent = englishLabels[index];
        chip.setAttribute('data-question', englishText);
      } else {
        const koreanText = chip.getAttribute('data-question');
        const koreanLabels = ['ì—°êµ¬ ë¶„ì•¼', 'íŒ€ êµ¬ì„±ì›', 'ì§€ì› ë°©ë²•', 'ì—°ë½ì²˜'];
        const index = Array.from(suggestionChipsElements).indexOf(chip);
        chip.textContent = koreanLabels[index];
      }
    });

    // Update operating hours text based on language
    if (chatbotSchedule) {
      if (isEnglish) {
        chatbotSchedule.textContent = 'Hours: 08:00-04:00 next day (KST)';
      } else {
        chatbotSchedule.textContent = 'ìš´ì˜ì‹œê°„: 08:00-ìµì¼ 04:00 (í•œêµ­ì‹œê°„)';
      }
    }

    // Update mode labels and content based on current language
    if (isAIMode) {
      aiLabel.classList.add('active');
      searchLabel.classList.remove('active');
      if (isEnglish) {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'AI will answer about our research lab!';
        chatbotInput.placeholder = 'Ask AI anything about our lab...';
      } else {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'AIê°€ ì—°êµ¬ì‹¤ì— ëŒ€í•´ ë‹µë³€í•´ë“œë¦½ë‹ˆë‹¤!';
        chatbotInput.placeholder = 'AIì—ê²Œ ê¶ê¸ˆí•œ ê²ƒì„ ë¬¼ì–´ë³´ì„¸ìš”...';
      }
    } else {
      searchLabel.classList.add('active');
      aiLabel.classList.remove('active');
      if (isEnglish) {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'Ask anything about our research lab!';
        chatbotInput.placeholder = 'Ask anything about our lab...';
      } else {
        chatbotTitle.textContent = 'Reality Lab Assistant';
        chatbotSubtitle.textContent = 'ì—°êµ¬ì‹¤ì— ëŒ€í•´ ê¶ê¸ˆí•œ ê²ƒì„ ë¬¼ì–´ë³´ì„¸ìš”!';
        chatbotInput.placeholder = 'ê¶ê¸ˆí•œ ê²ƒì„ ë¬¼ì–´ë³´ì„¸ìš”...';
      }
    }
  }

  // Handle input
  async function handleSend() {
    const question = chatbotInput.value.trim();
    if (!question) return;

    // Add user message
    addMessage(question, 'user');
    chatbotInput.value = '';

    // Generate and add bot response
    if (isAIMode) {
      // AI mode - use dynamic GPU allocation
      try {
        // Show thinking message directly if server is preconnected, otherwise show connection message
        if (GPU_MANAGER_URL) {
          // GPU Manager mode - check session status
          if (!currentSession && !isConnecting) {
            addMessage(isEnglish ? 'Connecting to AI server...' : 'AIì„œë²„ì— ì—°ê²°ì¤‘ì…ë‹ˆë‹¤...', 'bot');
          } else {
            addMessage(isEnglish ? 'Thinking...' : 'ìƒê° ì¤‘...', 'bot');
          }
        } else {
          // Direct connection mode - always show thinking if preconnected
          if (isAIServerReady) {
            addMessage(isEnglish ? 'Thinking...' : 'ìƒê° ì¤‘...', 'bot');
          } else {
            addMessage(isEnglish ? 'Connecting to AI server...' : 'AIì„œë²„ì— ì—°ê²°ì¤‘ì…ë‹ˆë‹¤...', 'bot');
          }
        }
        
        // Use streaming for real-time response
        const aiResult = await callAIServerStream(question, isEnglish);

        // Clear thinking timer
        clearThinkingTimer();

        // Get the last message (which was updated during streaming)
        const messages = chatbotMessages.querySelectorAll('.message');
        const lastMessage = messages[messages.length - 1];

        if (lastMessage && lastMessage.classList.contains('bot-message')) {
          // Remove thinking timer if it exists
          const thinkingTimer = lastMessage.querySelector('.thinking-timer');
          if (thinkingTimer) {
            thinkingTimer.remove();
          }

          // Remove cursor from streaming
          const contentDiv = lastMessage.querySelector('div:first-child');
          if (contentDiv) {
            const cursorSpan = contentDiv.querySelector('.typing-cursor');
            if (cursorSpan) {
              cursorSpan.remove();
            }
          }
        }

        const response = aiResult?.response || aiResult || 'No response';
        const responseTime = (aiResult?.response_time && typeof aiResult.response_time === 'number') ? aiResult.response_time : null;
        const tokens = (aiResult?.tokens && typeof aiResult.tokens === 'number') ? aiResult.tokens : null;

        // Check if response seems uncertain or generic for AI fallback
        let finalResponse = response;
        if (isResponseUncertain(response)) {
          const uncertaintyMessage = isEnglish ?
            "I'm not completely certain about this answer. If you need more specific information, please click " :
            "ì´ ë‹µë³€ì´ í™•ì‹¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë” êµ¬ì²´ì ì¸ ì •ë³´ê°€ í•„ìš”í•˜ì‹œë‹¤ë©´, ";

          const envelopeEmoji = 'ğŸ“©';
          const fallbackSuffix = isEnglish ?
            " to submit your question for review by our lab members." :
            "ë¥¼ í´ë¦­í•´ ìµëª…ìœ¼ë¡œ ë‹µë³€ ì¶”ê°€ ìš”ì²­ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.";

          finalResponse += "\n\n" + uncertaintyMessage + `<span class="envelope-emoji" onclick="showQuestionModal()">${envelopeEmoji}</span>` + fallbackSuffix;
        }

        // Update the message content with final response
        if (lastMessage && lastMessage.classList.contains('bot-message')) {
          const contentDiv = lastMessage.querySelector('div:first-child');
          if (contentDiv) {
            contentDiv.innerHTML = finalResponse.replace(/\n/g, '<br>');
          }

          // Add response time and token count
          if (responseTime !== null && typeof responseTime === 'number' && responseTime > 0) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'response-time';
            const tokenInfo = tokens && tokens > 0 ? ` Â· ${tokens}í† í°` : '';
            timeDiv.innerHTML = `<small style="color: #888; font-size: 11px;">ì‘ë‹µ ì‹œê°„: ${responseTime}ì´ˆ${tokenInfo}</small>`;
            lastMessage.appendChild(timeDiv);
          }
        }
      } catch (error) {
        console.error('Error in AI response:', error);
        // Clear thinking timer on error
        clearThinkingTimer();
        // Remove the loading message on error
        const messages = chatbotMessages.querySelectorAll('.message');
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.classList.contains('bot-message')) {
          const thinkingTimer = lastMessage.querySelector('.thinking-timer');
          if (thinkingTimer) {
            thinkingTimer.remove();
          }
          lastMessage.remove();
        }
        addMessage(
          isEnglish ? 'ğŸ’¤ AI is taking a break right now. Please try during operating hours (08:00-04:00 KST)!' : 'ğŸ’¤ AIê°€ ì§€ê¸ˆ ì‰¬ëŠ” ì‹œê°„ì´ì—ìš”. ìš´ì˜ì‹œê°„(08:00-ìµì¼ 04:00)ì— ë‹¤ì‹œ ì°¾ì•„ì£¼ì„¸ìš”!',
          'bot'
        );
      }
    } else {
      // Search mode - use existing knowledge base
      setTimeout(() => {
        const answer = generateAnswer(question);
        addMessage(answer, 'bot');
      }, 500);
    }
  }

  // Think mode dropdown toggle
  thinkModeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    thinkModeMenu.classList.toggle('show');
    thinkModeBtn.classList.toggle('active');
  });

  // Chat mode option selection
  thinkModeOptions.forEach(option => {
    option.addEventListener('click', (e) => {
      e.stopPropagation();
      chatMode = option.dataset.mode;
      localStorage.setItem('chatMode', chatMode);

      updateThinkModeUI();

      // Close dropdown
      thinkModeMenu.classList.remove('show');
      thinkModeBtn.classList.remove('active');

      const modeNames = { 'fast': 'Fast (ë¹ ë¦„)', 'deep': 'Deep (ì‹¬ì¸µ)', 'test': 'Test (8B ê°œë°œì „ìš©)' };
      console.log('Chat mode:', modeNames[chatMode]);
    });
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!thinkModeBtn.contains(e.target) && !thinkModeMenu.contains(e.target)) {
      thinkModeMenu.classList.remove('show');
      thinkModeBtn.classList.remove('active');
    }
  });

  chatbotSend.addEventListener('click', handleSend);
  chatbotInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      handleSend();
    }
  });

  // Suggestion chips
  suggestionChips.forEach(chip => {
    chip.addEventListener('click', () => {
      const question = isEnglish ? chip.dataset.questionEn : chip.dataset.question;
      chatbotInput.value = question;
      handleSend();
    });
  });

  // Timer variables
  let thinkingTimer = null;
  let thinkingStartTime = null;

  // Add message to chat
  function addMessage(content, type, responseTime = null, tokens = null) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}-message`;
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';
    contentDiv.innerHTML = content.replace(/\n/g, '<br>');
    
    messageDiv.appendChild(contentDiv);
    
    // Add response time for bot messages - only if it's a valid number
    if (type === 'bot' && responseTime !== null && typeof responseTime === 'number' && responseTime > 0) {
      const timeDiv = document.createElement('div');
      timeDiv.className = 'response-time';
      const tokenInfo = tokens && tokens > 0 ? ` Â· ${tokens}í† í°` : '';
      timeDiv.innerHTML = `<small style="color: #888; font-size: 11px;">ì‘ë‹µ ì‹œê°„: ${responseTime}ì´ˆ${tokenInfo}</small>`;
      messageDiv.appendChild(timeDiv);
    }
    
    chatbotMessages.appendChild(messageDiv);
    
    // Start real-time timer for thinking messages after DOM insertion
    if (type === 'bot' && (content.includes('ìƒê° ì¤‘') || content.includes('Thinking'))) {
      const timeDiv = document.createElement('div');
      timeDiv.className = 'thinking-timer';
      timeDiv.innerHTML = `<small style="color: #888; font-size: 11px;">ì‘ë‹µ ì‹œê°„: 0ì´ˆ</small>`;
      messageDiv.appendChild(timeDiv);
      
      // Start timer
      thinkingStartTime = Date.now();
      thinkingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - thinkingStartTime) / 1000);
        const timerElement = messageDiv.querySelector('.thinking-timer small');
        if (timerElement) {
          timerElement.innerHTML = `ì‘ë‹µ ì‹œê°„: ${elapsed}ì´ˆ`;
        } else {
          clearInterval(thinkingTimer);
        }
      }, 1000);
    }
    
    // Scroll to bottom
    chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
  }


  // Clear thinking timer
  function clearThinkingTimer() {
    if (thinkingTimer) {
      clearInterval(thinkingTimer);
      thinkingTimer = null;
      thinkingStartTime = null;
    }
  }

  // Simple knowledge-based answer generation
  function generateAnswer(question) {
    const q = question.toLowerCase();
    
    // Contact info (with language toggle) - Check this FIRST
    if (q.includes('ì—°ë½') || q.includes('ì´ë©”ì¼') || q.includes('ì „í™”') || q.includes('ì—°ë½ì²˜') || 
        q.includes('contact') || q.includes('email') || q.includes('phone') || q.includes('number')) {
      
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `Contact Information:\nâ€¢ Email: ${labInfo.email}\nâ€¢ Phone: ${labInfo.phone}\nâ€¢ Location: ${labInfo.location}`;
      } else {
        return `ì—°ë½ì²˜ ì •ë³´ì…ë‹ˆë‹¤:\nâ€¢ ì´ë©”ì¼: ${labInfo.email}\nâ€¢ ì „í™”: ${labInfo.phone}\nâ€¢ ìœ„ì¹˜: ${labInfo.location}`;
      }
    }
    
    // Check custom Q&A after language-specific responses
    const customQAs = isEnglish ? knowledgeBase.custom_qa.en : knowledgeBase.custom_qa.ko;
    for (const qa of customQAs) {
      // Check question match
      if (q.includes(qa.question.toLowerCase()) || 
          qa.question.toLowerCase().includes(q) ||
          checkSimilarity(q, qa.question.toLowerCase())) {
        return qa.answer;
      }
      
      // Check keywords match
      if (qa.keywords) {
        for (const keyword of qa.keywords) {
          if (q.includes(keyword.toLowerCase())) {
            return qa.answer;
          }
        }
      }
    }
    
    // Research areas (with language toggle)
    for (const area of knowledgeBase.research_areas) {
      const areaKo = area.ko;
      const areaEn = area.en;
      
      for (const keyword of [...areaKo.keywords, ...areaEn.keywords]) {
        if (q.includes(keyword.toLowerCase()) || 
            q.includes(areaKo.name.toLowerCase()) || 
            q.includes(areaEn.name.toLowerCase())) {
          
          if (isEnglish) {
            return `${areaEn.name}: ${areaEn.description}`;
          } else {
            return `${areaKo.name}: ${areaKo.description}`;
          }
        }
      }
    }
    
    // Team members (with language toggle)
    if (q.includes('íŒ€') || q.includes('êµ¬ì„±ì›') || q.includes('ë©¤ë²„') || q.includes('ì‚¬ëŒ') ||
        q.includes('team') || q.includes('member') || q.includes('people') || q.includes('staff')) {
      
      let teamInfo;
      
      if (isEnglish) {
        teamInfo = "Let me introduce Reality Lab team members:\n\n";
        knowledgeBase.team_members.en.forEach(member => {
          teamInfo += `â€¢ ${member.name} - ${member.role}\n`;
        });
      } else {
        teamInfo = "Reality Lab íŒ€ êµ¬ì„±ì›ë“¤ì„ ì†Œê°œí•´ë“œë¦´ê²Œìš”:\n\n";
        knowledgeBase.team_members.ko.forEach(member => {
          teamInfo += `â€¢ ${member.name} - ${member.role}\n`;
        });
      }
      return teamInfo;
    }
    
    // Lab info (with language toggle)
    if (q.includes('ì—°êµ¬ì‹¤') || q.includes('ë©') || q.includes('ì†Œê°œ') ||
        q.includes('lab') || q.includes('about') || q.includes('introduction') || q.includes('info')) {
      
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `${labInfo.full_name} was established in ${labInfo.established}. Led by ${labInfo.director}, ${labInfo.mission}`;
      } else {
        return `${labInfo.full_name}ì€ ${labInfo.established}ë…„ì— ì„¤ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤. ${labInfo.director}ë‹˜ì´ ì´ë„ì‹œë©°, ${labInfo.mission}`;
      }
    }
    // Location (with language toggle)
    if (q.includes('ìœ„ì¹˜') || q.includes('ì–´ë””') || q.includes('location') || q.includes('where') || q.includes('address')) {
      const labInfo = isEnglish ? knowledgeBase.lab_info.en : knowledgeBase.lab_info.ko;
      
      if (isEnglish) {
        return `Reality Lab is located at ${labInfo.location}.`;
      } else {
        return `Reality Labì€ ${labInfo.location}ì— ìœ„ì¹˜í•˜ê³  ìˆìŠµë‹ˆë‹¤.`;
      }
    }
    
    // Fallback with envelope emoji
    const baseMessage = isEnglish ? 
      "I don't have specific information about that. If you have questions, please click " :
      "ê¶ê¸ˆí•œ ë‚´ìš©ì´ ìˆë‹¤ë©´, ";
    
    const envelopeEmoji = 'ğŸ“©';
    const fallbackSuffix = isEnglish ?
      " to submit your question for review by our lab members. Feel free to use it!" :
      "ë¥¼ í´ë¦­í•´ ìµëª…ìœ¼ë¡œ ë‹µë³€ ì¶”ê°€ ìš”ì²­ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. í¸í•˜ê²Œ ì‚¬ìš©í•´ì£¼ì„¸ìš”.";
    
    return baseMessage + `<span class="envelope-emoji" onclick="showQuestionModal()">${envelopeEmoji}</span>` + fallbackSuffix;
  }

  // Simple similarity check
  function checkSimilarity(str1, str2) {
    const words1 = str1.split(' ');
    const words2 = str2.split(' ');
    let matchCount = 0;
    
    words1.forEach(word1 => {
      if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
        matchCount++;
      }
    });
    
    return matchCount >= Math.min(words1.length, words2.length) * 0.4;
  }

  // Check if AI response seems uncertain
  function isResponseUncertain(response) {
    // Only trigger for very specific uncertainty patterns
    const strongUncertaintyKeywords = [
      // Very specific uncertainty expressions
      'í™•ì‹¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤', 'ì •í™•í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤', 'ëª¨ë¥´ê² ìŠµë‹ˆë‹¤', 'ì˜ ëª¨ë¥´ê² ìŠµë‹ˆë‹¤',
      // Missing information expressions
      'ì œê³µëœ ì •ë³´ì— ë”°ë¥´ë©´.*ì—†ìŠµë‹ˆë‹¤', 'êµ¬ì²´ì ì¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤', 'êµ¬ì²´ì ì¸ ë‚´ìš©ì€ ì—†ìŠµë‹ˆë‹¤',
      'ê³µì‹ì ìœ¼ë¡œ ì œê³µëœ ì •ë³´ì— ëª…ì‹œë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤', 'ëª…ì‹œë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤',
      // Direct contact recommendations (what we want to avoid)
      'ì§ì ‘ ë¬¸ì˜í•˜ëŠ” ê²ƒì´ ê°€ì¥', 'ì§ì ‘ ì—°ë½í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤', 'ì§ì ‘ í™•ì¸í•´ë³´ì„¸ìš”',
      // English uncertainty
      'not sure about', 'uncertain about', 'no specific information', 'not available in',
      'not officially provided', 'contact directly', 'please contact'
    ];
    
    // Check for strong uncertainty patterns only
    const lowerResponse = response.toLowerCase();
    const hasStrongUncertainty = strongUncertaintyKeywords.some(keyword => 
      lowerResponse.includes(keyword.toLowerCase())
    );
    
    // Check for very specific uncertainty patterns that we definitely want to catch
    const criticalUncertaintyPatterns = [
      /ê³µì‹ì ìœ¼ë¡œ.*?ì œê³µëœ.*?ì •ë³´.*?ëª…ì‹œë˜ì–´.*?ìˆì§€.*?ì•ŠìŠµë‹ˆë‹¤/,
      /êµ¬ì²´ì ì¸.*?ì •ë³´.*?ì—†ìŠµë‹ˆë‹¤/,
      /ì§ì ‘.*?ë¬¸ì˜.*?ê°€ì¥.*?ì‹ ë¢°í• .*?ìˆ˜.*?ìˆìŠµë‹ˆë‹¤/,
      /ì •í™•í•œ.*?ì •ë³´.*?í™•ì¸í•˜ë ¤ë©´.*?ì§ì ‘.*?ë¬¸ì˜/
    ];
    
    const hasCriticalUncertaintyPattern = criticalUncertaintyPatterns.some(pattern => pattern.test(response));
    
    // Only check for content reliability, not length
    // Envelope should appear when AI is genuinely uncertain about information
    return hasCriticalUncertaintyPattern || hasStrongUncertainty;
  }

  // Drag functionality
  let isDragging = false;
  let currentX = 0;
  let currentY = 0;
  let initialX = 0;
  let initialY = 0;
  let xOffset = 0;
  let yOffset = 0;

  const chatbotHeader = document.querySelector('.chatbot-header');
  
  if (chatbotHeader) {
    chatbotHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
  }

  function dragStart(e) {
    if (e.target === chatbotClose || e.target.closest('.chatbot-close')) return;
    
    initialX = e.clientX - xOffset;
    initialY = e.clientY - yOffset;

    if (e.target === chatbotHeader || chatbotHeader.contains(e.target)) {
      isDragging = true;
      chatbotWindow.style.transition = 'none';
    }
  }

  function dragMove(e) {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;

      xOffset = currentX;
      yOffset = currentY;

      // Convert to fixed positioning when dragging
      if (chatbotWindow.style.position !== 'fixed') {
        const rect = chatbotWindow.getBoundingClientRect();
        chatbotWindow.style.position = 'fixed';
        chatbotWindow.style.bottom = 'auto';
        chatbotWindow.style.right = 'auto';
        chatbotWindow.style.top = rect.top + 'px';
        chatbotWindow.style.left = rect.left + 'px';
      }

      chatbotWindow.style.transform = `translate(${currentX}px, ${currentY}px)`;
    }
  }

  function dragEnd(e) {
    initialX = currentX;
    initialY = currentY;
    isDragging = false;
    chatbotWindow.style.transition = '';
  }

  // AI Info tooltip functionality
  const aiInfoTrigger = document.getElementById('ai-info-trigger');
  const aiInfoTooltip = document.getElementById('ai-info-tooltip');
  const tooltipClose = document.getElementById('tooltip-close');
  const tooltipKo = aiInfoTooltip.querySelector('.tooltip-ko');
  const tooltipEn = aiInfoTooltip.querySelector('.tooltip-en');
  
  let tooltipTimeout;
  let isTooltipPinned = false; // Track if tooltip is pinned (clicked)

  function showAIInfoTooltip() {
    clearTimeout(tooltipTimeout);
    
    // Show correct language tooltip
    if (isEnglish) {
      tooltipKo.style.display = 'none';
      tooltipEn.style.display = 'block';
    } else {
      tooltipKo.style.display = 'block';
      tooltipEn.style.display = 'none';
    }
    
    aiInfoTooltip.classList.add('show');
  }

  function hideAIInfoTooltip() {
    if (!isTooltipPinned) {
      tooltipTimeout = setTimeout(() => {
        aiInfoTooltip.classList.remove('show');
      }, 300);
    }
  }

  function forceHideTooltip() {
    isTooltipPinned = false;
    clearTimeout(tooltipTimeout);
    aiInfoTooltip.classList.remove('show');
  }

  if (aiInfoTrigger && aiInfoTooltip) {
    // Show on hover
    aiInfoTrigger.addEventListener('mouseenter', showAIInfoTooltip);
    aiInfoTrigger.addEventListener('mouseleave', hideAIInfoTooltip);
    
    // Pin on click
    aiInfoTrigger.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (aiInfoTooltip.classList.contains('show') && isTooltipPinned) {
        forceHideTooltip();
      } else {
        showAIInfoTooltip();
        isTooltipPinned = true;
      }
    });

    // Keep tooltip visible when hovering over it
    aiInfoTooltip.addEventListener('mouseenter', () => {
      clearTimeout(tooltipTimeout);
    });
    
    aiInfoTooltip.addEventListener('mouseleave', hideAIInfoTooltip);
    
    // Close button functionality
    if (tooltipClose) {
      tooltipClose.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        forceHideTooltip();
      });
    }
    
    // Close when clicking outside
    document.addEventListener('click', function(e) {
      if (!aiInfoTrigger.contains(e.target) && !aiInfoTooltip.contains(e.target)) {
        forceHideTooltip();
      }
    });
    
    // Update tooltip and text language when language buttons are clicked
    const langBtns = document.querySelectorAll('.lang-btn');
    langBtns.forEach(btn => {
      const originalClickHandler = btn.onclick;
      btn.onclick = function(e) {
        if (originalClickHandler) {
          originalClickHandler.call(this, e);
        }
        
        // Update tooltip if it's currently shown
        setTimeout(() => {
          if (aiInfoTooltip.classList.contains('show')) {
            if (isEnglish) {
              tooltipKo.style.display = 'none';
              tooltipEn.style.display = 'block';
            } else {
              tooltipKo.style.display = 'block';
              tooltipEn.style.display = 'none';
            }
          }
        }, 50);
      };
    });
    
  }

  // Global function to show question modal
  window.showQuestionModal = function() {
    const modal = document.getElementById('question-modal');
    if (modal) {
      modal.style.display = 'flex';
      document.getElementById('question-textarea').focus();
    }
  };

  // Modal functionality
  const questionModal = document.getElementById('question-modal');
  const modalClose = document.getElementById('modal-close');
  const modalCancel = document.getElementById('modal-cancel');
  const modalSend = document.getElementById('modal-send');
  const questionTextarea = document.getElementById('question-textarea');
  const charCount = document.getElementById('char-count');
  const modalBackdrop = document.querySelector('.modal-backdrop');

  function closeModal() {
    if (questionModal) {
      questionModal.style.display = 'none';
      questionTextarea.value = '';
      charCount.textContent = '0';
    }
  }

  if (modalClose) modalClose.addEventListener('click', closeModal);
  if (modalCancel) modalCancel.addEventListener('click', closeModal);
  if (modalBackdrop) modalBackdrop.addEventListener('click', closeModal);

  // Character counter
  if (questionTextarea && charCount) {
    questionTextarea.addEventListener('input', function() {
      charCount.textContent = this.value.length;
    });
  }

  // Server-side GitHub Issue Creation
  async function submitQuestionToServer(question) {
    try {
      // Try to get current session endpoints first
      const endpoints = getCurrentEndpoints();
      let submitEndpoint;
      
      if (endpoints) {
        submitEndpoint = endpoints.submitQuestion;
      } else {
        // Fallback to allocate a GPU temporarily for question submission
        const session = await allocateGPU();
        if (session) {
          const newEndpoints = getCurrentEndpoints();
          submitEndpoint = newEndpoints?.submitQuestion;
        }
      }
      
      if (!submitEndpoint) {
        throw new Error('GPU ì—°ê²°ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      const response = await fetch(submitEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          question: question
        })
      });
      
      const result = await response.json();
      
      if (result.success) {
        return {
          success: true,
          message: result.message,
          issueNumber: result.issue_number
        };
      } else {
        throw new Error(result.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('Error submitting question:', error);
      return {
        success: false,
        error: error.message || 'ì§ˆë¬¸ ì œì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
      };
    }
  }

  // Send question functionality
  if (modalSend) {
    modalSend.addEventListener('click', async function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const question = questionTextarea.value.trim();
      if (!question) {
        alert('ì§ˆë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
        return;
      }
      
      // Disable send button during processing
      modalSend.disabled = true;
      modalSend.textContent = 'ì œì¶œ ì¤‘...';
      
      try {
        // Submit question directly to server
        const result = await submitQuestionToServer(question);
        
        if (result.success) {
          alert(`ì„±ê³µ! ì§ˆë¬¸ì´ ì œì¶œë˜ì—ˆìŠµë‹ˆë‹¤. (GitHub ì´ìŠˆ #${result.issueNumber})\n\nì—°êµ¬ì‹¤ ê´€ê³„ìê°€ ê²€í†  í›„ ë‹µë³€ì„ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.`);
          closeModal();
        } else {
          alert(`ì˜¤ë¥˜: ${result.error}\n\në‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ heewon@ssu.ac.krë¡œ ì—°ë½í•´ì£¼ì„¸ìš”.`);
        }
      } catch (error) {
        console.error('Error creating issue URL:', error);
        alert('ì£„ì†¡í•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ì—°êµ¬ì‹¤ì— ì§ì ‘ ì—°ë½í•´ì£¼ì„¸ìš”.');
      } finally {
        // Re-enable send button
        modalSend.disabled = false;
        modalSend.textContent = 'ë³´ë‚´ê¸°';
      }
    });
  }
});
</script>